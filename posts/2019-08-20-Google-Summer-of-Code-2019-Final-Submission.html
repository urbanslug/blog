<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <link rel="apple-touch-icon" sizes="57x57" href="../images/favicon/apple-icon-57x57.png">
        <link rel="apple-touch-icon" sizes="60x60" href="../images/favicon/apple-icon-60x60.png">
        <link rel="apple-touch-icon" sizes="72x72" href="../images/favicon/apple-icon-72x72.png">
        <link rel="apple-touch-icon" sizes="76x76" href="../images/favicon/apple-icon-76x76.png">
        <link rel="apple-touch-icon" sizes="114x114" href="../images/favicon/apple-icon-114x114.png">
        <link rel="apple-touch-icon" sizes="120x120" href="../images/favicon/apple-icon-120x120.png">
        <link rel="apple-touch-icon" sizes="144x144" href="../images/favicon/apple-icon-144x144.png">
        <link rel="apple-touch-icon" sizes="152x152" href="../images/favicon/apple-icon-152x152.png">
        <link rel="apple-touch-icon" sizes="180x180" href="../images/favicon/apple-icon-180x180.png">
        <link rel="icon" type="image/png" sizes="192x192" href="../images/favicon/android-icon-192x192.png">
        <link rel="icon" type="image/png" sizes="32x32" href="../images/favicon/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="96x96" href="../images/favicon/favicon-96x96.png">
        <link rel="icon" type="image/png" sizes="16x16" href="../images/favicon/favicon-16x16.png">
        <link rel="manifest" href="../images/favicon/manifest.json">
        <meta name="msapplication-TileColor" content="#ffffff">
        <meta name="msapplication-TileImage" content="/images/favicon/ms-icon-144x144.png">
        <meta name="theme-color" content="#ffffff">
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <title>Google Summer of Code 2019—Final Submission urbanslug</title>
    </head>
    <body>
      <div id="wrapper">
        <header>
          <div id="header-content">
            <nav>
                <a href="../">Home</a>
                <a href="../notes.html">Notes</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../subscribe.html">Subscribe</a>
            </nav>
          </div><!--header-content-->
        </header>
        <article>
          <h1 id="post-title">Google Summer of Code 2019—Final Submission</h1>
          <div class="info">
    Posted on September 20, 2019
    
</div>
<div class="info">
    
    Tags: <a href="../tags/GSoC.html">GSoC</a>, <a href="../tags/Google%20Summer%20of%20Code.html">Google Summer of Code</a>, <a href="../tags/Variation%20Graphs.html">Variation Graphs</a>, <a href="../tags/Bioinformatics.html">Bioinformatics</a>
    
</div>

<p>The Google Summer of Code for 2019 is coming to a close. I’ve been working on the <a href="https://github.com/urbanslug/graphite">Graphite</a> project aimed at creating a variation graph tool under the <a href="https://www.open-bio.org/">Open Bioinformatics Foundation</a>.</p>
<h1 id="genome-graphs">Genome Graphs</h1>
<p>I shall give an overview of genome graphs; for a more thorough introduction, I advise reading <a href="https://lh3.github.io/2019/07/08/on-a-reference-pan-genome-model">On a reference pan-genome model</a> or my very own <a href="2019-06-22-Introduction-to-Variation-Graphs.html">An Introduction to Variation Graphs</a>.</p>
<p><a href="https://ekg.github.io/2019/07/09/Untangling-graphical-pangenomics">Variation graphs</a> are a class of <a href="https://www.biorxiv.org/content/10.1101/101378v1">genome graphs</a> that, among other things, maintain:</p>
<ul>
<li>path information—a full walk within the graph along the edges</li>
<li>a strong mapping between nodes on the graph and their positions on the reference</li>
</ul>
<p>All this with the main aim of representing genomic variation.</p>
<p>Currently genomes are represented as a consensus; for example, here’s part of <a href="https://github.com/vgteam/vg/blob/master/test/1mb1kgp/z.fa">chromosome 20 of the human genome</a>:</p>
<pre><code>TGGGAGAGAACTGGAACAAGAACCCAGTGCTCTTTCTGCTCTACCCACTGACCCATCCTCTCACGCATCATACACCCATA
CTCCCATCCACCCACCTTCCCATTCATGCATTCACCCATTCACCCACCTTCCATCCATCTACCATCCACCACGTACCTAC
ACTCCCATCTACCATCCAACCACATTTCCATTCACCCATCCTCCCATCCATCAACCCTCCAATCCACCACCCACAGACCT
TCCCATCCATTCATTTACCCATCCACATATTCACCCACCCTCCCATCCATCCATCTACTGTCTATCACCTACTCATTTTC
...</code></pre>
<p>However, variation <strong>does</strong> exist on this chromosome between individuals. To demonstrate, when <a href="https://github.com/vgteam/vg/blob/master/test/1mb1kgp/z.vcf.gz">a single file of variation data</a> is “applied” to it we end up with a graph that can be represented as in the below zoomed in section of chromosome 20. <img src="../images/Content/Graphs/chr20.png" alt="chr20" /></p>
<p>Not all graphs are linear like the one above; in fact, the kind of graphs we’re hoping to generate soon will have many breaks and will look pretty jumbled up. The amount of variation within and between genomes depends on a lot of factors including but not limited to the organism(s) whose genomes are studying and how evolutionarily distant the genomes we are comparing are (pan-genomes).</p>
<h2 id="reference-bias">Reference Bias</h2>
<p>The reference being a consensus introduces a problem known as <a href="https://www.sevenbridges.com/reference-bias-challenges-and-solutions/">reference bias</a>; which is analogous to a false negative during read mapping, that is, claiming that a variation does not exist where it actually exists. <a href="https://www.nature.com/articles/nbt.4227">Research</a> has shown an improvement in read mapping of short read data when short reads are mapped to a reference graph instead of a reference consensus.</p>
<p>Currently, graphite shows that we can generate a graph from a reference and variation data and progressively update it; not far from what Heng Li theorizes in: <a href="https://lh3.github.io/2019/07/08/on-a-reference-pan-genome-model">On a reference pan-genome model</a>. We plan on supporting the generation of graphs from short and long-read data on its own (de novo), you can track its progress under <a href="https://github.com/urbanslug/graphite/projects/1">the alignment project board</a>.</p>
<h1 id="why-racket">Why Racket?</h1>
<p>You may wonder why Graphite is written in Racket yet the project name is <a href="https://summerofcode.withgoogle.com/projects/#4733198808907776">Add Variant Graph (VG) support to BioD</a>. Genome graphs have been theorized and written about for a while now but there are only a few tools that implement them and there has been even much less use by bioinformaticians.</p>
<p>We decided to build something people can use over just adding variation graph support to <a href="https://github.com/biod/biod">BioD</a> believing that it would’ve taken me longer to write something people could use in D.</p>
<h2 id="but-why-racket-and-not-another-language-or-lisp">But why Racket and not another language or LISP?</h2>
<p>I have experience in functional programming and particularly professional experience with LISPs, I could, therefore, move much faster in it. Racket is a good LISP to work in in an unfamiliar domain because it has a <strong>straightforward build system</strong> compared to the overhead of the JVM and leiningen in the most popular LISP, Clojure does and has an <strong>easy to use C/C++ FFI</strong>, languages used in a lot of Bioinformatics applications and libraries. Being <strong>untyped</strong> and programming in LISP being <strong>REPL driven</strong> also helps to venture into unfamiliar territory. Racket has <strong>immutability</strong> in a lot, if not all, of its data structures which also helps with all the data manipulation we would have to do. Finally, Racket also <strong>implements core programming concepts elegantly</strong> compared to many other languages for example with its hygienic macros.</p>
<p>This shouldn’t make the D community feel betrayed because given what we know now, we can always go back and reimplement either all or part of Graphite in D, especially for the possible performance improvements.</p>
<h1 id="done">Done</h1>
<p>For the fine detail install and set up Graphite as instructed in the <a href="https://github.com/urbanslug/graphite#graphite">README</a> and run <code>graphite --help</code>.</p>
<h2 id="underlying-graph-representation">Underlying graph representation</h2>
<p>We implemented the graph as an association hash table. I went into more detail on how it’s built and the rationale behind certain choices in <a href="2019-07-15-Creating-the-Initial-Variation-Graph.html">Creating the Initial Variation Graph</a> and <a href="2019-07-21-Justifying-SHA256-in-Graphite.html">Justifying SHA256 in Graphite</a>.</p>
<h2 id="construct">Construct</h2>
<p>Graphite allows you to build an initial graph out of a reference in <a href="https://en.wikipedia.org/wiki/FASTA_format">FASTA format</a> and a <a href="https://en.wikipedia.org/wiki/Variant_Call_Format">VCF</a> file. In the example below I output a serialized graph but you can output <code>.dot</code> or <code>.gfa</code>.</p>
<pre><code>./bin/graphite construct \
 -o rsv1.gra \
 -f gra \
 data/RSV/refererence_and_vcf_file/9465113.fa data/RSV/refererence_and_vcf_file/H_3801_22_04.freebayes.vcf</code></pre>
<h2 id="update">Update</h2>
<p>Formally, <em>progressive construction</em>. Graphite lets the user update a serialized graph generated via <code>construct</code>. In the update, it takes serialized graph <code>.gra</code> and variation data in VCF. Example:</p>
<pre><code>./bin/graphite update \
 -o rsv2.dot \
 -f dot \
 rsv1.gra data/RSV/refererence_and_vcf_file/fake_H_3801_22_04.freebayes.vcf</code></pre>
<h2 id="view">View</h2>
<p>Graphite allows you to generate graphs in</p>
<ul>
<li><strong>dot</strong> for visualization via <a href="https://en.wikipedia.org/wiki/Graphviz">GraphViz</a></li>
<li><strong>gfa</strong> for visualization with tools like <a href="https://rrwick.github.io/Bandage/">bandage</a></li>
<li><strong>gra</strong> a serialized graph, it can’t be visualized.</li>
</ul>
<p>Using <code>update</code> and <code>view</code>, one can visualize changes introduced by different VCF files as of writing this. The view command takes a serialized graph <code>.gra</code>, an output format, and an output file as arguments. Example:</p>
<pre><code>./bin/graphite view \
 -o rsv1.dot \
 -f dot \
 rsv1.gra</code></pre>
<h1 id="to-do">To Do</h1>
<p>Look at the <a href="https://github.com/urbanslug/graphite/projects">Graphite project boards</a> for further detail.</p>
<h2 id="partial-order-alignment">Partial Order Alignment</h2>
<p>This would allow for aligning reads to a graph or against each other bypassing the consensus reference.</p>
<p>For now, graphite can only align against strings (however this functionality isn’t exposed because it’s not ready yet) mainly because it only stores forward edges which makes it hard to implement Partial Order Alignment (POA) which strictly depends on backward edges. The short term options are adding a pre-processing step to generate backward edges or using Racket’s FFI to call <a href="https://github.com/rvaser/spoa">spoa</a> or <a href="https://github.com/vgteam/gssw">gssw</a>. In the medium to long term Graphite’s nodes should support backward edges which would, on top of assisting with POA, allow for encoding more complex mutations such as inversions.</p>
<h2 id="search">Search</h2>
<p>This involves having a kmer, the substring of a genome, and searching for its most likely position in the graph. I have multiple problems with this as of now such as completely not finding kmers at all or having them point to the wrong location.</p>
<h3 id="complementarity">Complementarity</h3>
<p>Graphite doesn’t support complementarity (only supports the positive strands) therefore searching for a kmer in the negative strand wouldn’t even work. I am evaluating different ways of implementing complementarity.</p>
<h3 id="a-graph-extension-of-the-burrows-wheeler-transform">A Graph Extension of the Burrows-Wheeler Transform</h3>
<p>Search doesn’t work for some strings and even worse the method I am using to build the index is not ideal. Currently, I am building the FM index via a Burrows-Wheeler Transform (BWT) which is in turn built from rotating the given string, this is far from ideal. A better strategy I am considering is:</p>
<ol style="list-style-type: decimal">
<li>generate a suffix tree via <a href="https://en.wikipedia.org/wiki/Ukkonen%27s_algorithm">Ukkonen’s algorithm</a></li>
<li>traverse the suffix tree via a depth-first search to build a suffix array</li>
<li>use the suffix array to generate a BWT</li>
</ol>
<p>I could then complement the BWT and then generate the FM index and therefore get fast queries onto the graph. I believe this to be the basic idea behind <a href="https://www.biorxiv.org/content/10.1101/051409v1">A Graph Extension of the Positional Burrows-Wheeler Transform and its Applications</a>.</p>
<h2 id="adding-a-metadata-field">Adding a Metadata Field</h2>
<p>We could add a metadata field to the nodes which will allow for something like inbuilt annotation support.</p>
<h2 id="miscellaneous">Miscellaneous</h2>
<p>Another feature not related to Bioinformatics but is surprisingly lacking in Racket is to extend <a href="https://github.com/racket/racket/blob/master/racket/collects/racket/cmdline.rkt">cmdline</a> to have command-line options as is described in <a href="https://pavpanchekha.com/blog/multi-command-line.html">Multi-command-line in Racket</a>.</p>
<p>To reiterate, you can look at these 3 other posts regarding Graphite:</p>
<ul>
<li><a href="2019-06-22-Introduction-to-Variation-Graphs.html">An Introduction to Variation Graphs</a></li>
<li><a href="2019-07-15-Creating-the-Initial-Variation-Graph.html">Creating the Initial Variation Graph</a></li>
<li><a href="2019-07-21-Justifying-SHA256-in-Graphite.html">Justifying SHA256 in Graphite</a></li>
</ul>
<h1 id="acknowledgements">Acknowledgements</h1>
<p>I’d like to acknowledge the contribution of the following people. My mentors</p>
<ul>
<li><a href="https://github.com/george-githinji">George Githinji</a></li>
<li><a href="https://github.com/pjotrp">Pjotr Prins</a></li>
</ul>
<p>and those who weren’t my mentors but helped along the way by offering technical advice, testing graphite, reading the code or reviewing the blog posts.</p>
<ul>
<li><a href="https://github.com/alanorth">Alan Orth</a></li>
<li><a href="https://github.com/ekg">Erik Garrison</a></li>
<li><a href="https://github.com/jasonrogena">Jason Rogena</a></li>
<li><a href="https://github.com/hipstermojo">Kenneth Gitere</a></li>
<li><a href="https://github.com/kevthanewversi">Kevin Murimi</a></li>
</ul>

<script src="https://carnivalapp.io/sites/413/init.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", Carnival.init);
</script>

        </article>

        <footer>
  <p>All work is under the terms of the <a href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License, Version 1.3</a></p>
  <p>Generated with <a href="https://jaspervdj.be/hakyll/">Hakyll</a>.</p>
        </footer>
      </div> <!-- #wrapper -->
    </body>
</html>
