<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <link rel="apple-touch-icon" sizes="57x57" href="../images/favicon/apple-icon-57x57.png">
        <link rel="apple-touch-icon" sizes="60x60" href="../images/favicon/apple-icon-60x60.png">
        <link rel="apple-touch-icon" sizes="72x72" href="../images/favicon/apple-icon-72x72.png">
        <link rel="apple-touch-icon" sizes="76x76" href="../images/favicon/apple-icon-76x76.png">
        <link rel="apple-touch-icon" sizes="114x114" href="../images/favicon/apple-icon-114x114.png">
        <link rel="apple-touch-icon" sizes="120x120" href="../images/favicon/apple-icon-120x120.png">
        <link rel="apple-touch-icon" sizes="144x144" href="../images/favicon/apple-icon-144x144.png">
        <link rel="apple-touch-icon" sizes="152x152" href="../images/favicon/apple-icon-152x152.png">
        <link rel="apple-touch-icon" sizes="180x180" href="../images/favicon/apple-icon-180x180.png">
        <link rel="icon" type="image/png" sizes="192x192" href="../images/favicon/android-icon-192x192.png">
        <link rel="icon" type="image/png" sizes="32x32" href="../images/favicon/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="96x96" href="../images/favicon/favicon-96x96.png">
        <link rel="icon" type="image/png" sizes="16x16" href="../images/favicon/favicon-16x16.png">
        <link rel="manifest" href="../images/favicon/manifest.json">
        <meta name="msapplication-TileColor" content="#ffffff">
        <meta name="msapplication-TileImage" content="/images/favicon/ms-icon-144x144.png">
        <meta name="theme-color" content="#ffffff">
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <title>Jusifying SHA256 in Graphite urbanslug</title>
    </head>
    <body>
      <div id="wrapper">
        <header>
          <div id="header-content">
            <nav>
                <a href="../">Home</a>
                <a href="../notes.html">Notes</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../subscribe.html">Subscribe</a>
            </nav>
          </div><!--header-content-->
        </header>
        <article>
          <h1 id="post-title">Jusifying SHA256 in Graphite</h1>
          <div class="info">
    Posted on July 21, 2019
    
</div>
<div class="info">
    
    Tags: <a href="../tags/probability.html">probability</a>, <a href="../tags/cryptography.html">cryptography</a>, <a href="../tags/variation.html">variation</a>, <a href="../tags/bioinformatics.html">bioinformatics</a>, <a href="../tags/graphite.html">graphite</a>
    
</div>

<p><a href="https://github.com/urbanslug/graphite">Graphite’s</a> underlying graph implementation is an adjacency hash table, a complicated way of saying that graphite uses a <a href="https://en.wikipedia.org/wiki/Hash_table">hash table</a> to implement the graph. The keys of the hash table are SHA256 hashes of the concatenation of: the <em>sequence</em>, a <em>plus symbol(+)</em>, and the <em>offset</em>.</p>
<p>Hashes also grant us outgoing edge representations, constant time lookups for queries of known sequence and position, and eliminate duplicates.</p>
<h1 id="computational-cost-of-hashing">Computational Cost of Hashing</h1>
<p>We have to compute a hash to uniquely identify each variation and we have to store each hash twice: first, as a <em>key</em> in the adjacency hash table; and second, as a field in the variation <code>structure</code> <em>value</em>. We must therefore examine the time and space costs of hashing.</p>
<h2 id="time">Time</h2>
<p>I couldn’t find any useful cost data on either the <a href="https://docs.racket-lang.org/sha/index.html">SHA-2 racket implementation</a> or <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">SHA-2</a>, the algorithm itself, but being a string algorithm you can assume it works in O(n) time, n being the length of the string being hashed.</p>
<p>This isn’t worrying because hashing is a one off cost which has proved inexpensive with the current variation data-set.</p>
<h2 id="space">Space</h2>
<p>This is more of a concern because we expect graphs to grow with time.</p>
<p>A SHA 256 hash takes the same amount of space as a 32 characters string (8*32=256). Therefore, for variations with sequences fewer than 32 nucleotides, we store a hash that is larger than the variation we are hashing (ignoring the plus symbol and offset). This is exemplified in SNP data.</p>
<h2 id="graph-comparison">Graph Comparison</h2>
<p>A nice effect from hashing is that we can compare simple graphs derived from the same reference by comparing their hashes. It goes without saying that there are better or more general ways to perform graph comparison.</p>
<h1 id="probability-of-collision">Probability of Collision</h1>
<p>We can approximate the probability of a collision using the function P(n) = 1-e<sup>-n<sup>2</sup>/(2d)</sup>. Where <em>n is the sample size</em> and <em>d is the total number of “buckets”</em>. For more about calculating this probability check out <a href="https://en.wikipedia.org/wiki/Birthday_problem#Approximations">Birthday Problem Approximations</a>.</p>
<p>To avoid a collision we need to make sure that our variations are fewer than the square root of the bucket size—the point at which we get 0.5 chance of having two different strings sharing the same hash. Think of it as the halfway point in a <a href="https://en.wikipedia.org/wiki/Binomial_distribution">binomial distribution</a> where past 0.5 we consider a collision to have occurred. In reality the halfway point occurs <strong>above</strong> the square root but it’s still an easy way of verifying that your sample size is within a safe range.</p>
<p>Here’s a Racket function derived from the one above that I used to approximate collision probability.</p>
<pre><code>(define (probability-of-collision  d n)
  (- 1 (/ 1 (exp (/ (expt n 2) (* 2 d))))))</code></pre>
<h2 id="the-birthday-paradox">The Birthday Paradox</h2>
<p>Using the approximation function above, we estimate that for every group of 23 randomly selected people (n=23, d=356), the probability that two of them share a birthday is 0.5; and in a sample of 357 people (n=357, d=356), the probability that two of them share a birthday is 1. <img src="../images/Content/Graphs/birthday.png" alt="birthday plot" /></p>
<h2 id="sha-256">SHA 256</h2>
<p>For SHA 256 the halfway probability of a hash collision occurs at a point above 2<sup>128</sup> <img src="../images/Content/Graphs/sha256.png" alt="sha256 plot" /></p>
<p><em>This may be hard to interpret because exponential functions grow very quickly.</em></p>
<p>Here’s the Racket code I used to generate these plots</p>
<pre><code>#lang racket

(require plot)

(define (probability-of-collision  d x)
  (- 1 (/ 1 (exp (/ (expt x 2) (* 2 d))))))

(define (label-point-at x y)
  (let* ([fn (lambda (v) (if (&gt; v (expt 10 6)) 'exponential 'positional))]
        [x* (~r #:precision 4 #:notation fn x)]
        [y* (~r #:precision 4 y)])
    (list (vrule x 0 y #:style 'long-dash)
          (hrule y 0 x #:style 'long-dash)
          (point-label (vector x y) (format &quot;x = ~a    y = ~a&quot; x* y*)))))

(define (plot-probability-of-collison bucket-size label [halfway-probability #f])
  (let ([g (if halfway-probability halfway-probability (sqrt bucket-size))]
        [bucket-size-root (sqrt bucket-size)]
        [fn               ((curry probability-of-collision) bucket-size)])
    (parameterize ([plot-x-transform  log-transform]
                   [plot-width 750])
      (plot
       (list
        (function fn 1  bucket-size #:label label)
        (label-point-at g (fn g)))
       #:x-label &quot;Sample size&quot;
       #:y-label &quot;Probability of collision&quot;))))

(plot-probability-of-collison 365 &quot;Birthday&quot; 23)

(plot-probability-of-collison (expt 2 256) &quot;SHA 256&quot;)</code></pre>
<h2 id="the-birthday-attack">The Birthday Attack</h2>
<p>In the <a href="https://en.wikipedia.org/wiki/Birthday_attack">birthday attack</a>, an attacker when given a hash, guesses a string that will generate the same hash. If there no collisions the attacker would have to come up with the exact string that generated the hash. If there are collisions the attacker could get away with guessing a different string.</p>
<p>This is out of the scope of this post but <a href="https://en.wikipedia.org/wiki/Birthday_attack">birthday attack</a> and <a href="https://en.wikipedia.org/wiki/Birthday_problem">birthday problem</a> wikipedia pages can provide further reading. There’s also this lecture on YouTube from the Coursera cryptography course <a href="https://www.youtube.com/watch?v=5VY2KEh9WrE">Cryptography generic birthday attack (collision resistance)</a>.</p>
<h1 id="applied-to-variation">Applied to Variation</h1>
<p>For a 256 bit hash we have 2<sup>256</sup> as our bucket size. We then have the square root of that being 2<sup>(256/2)</sup> = 2<sup>128</sup> approximately 3.4*10<sup>38</sup> as the sample size below which we have 0.5 chance of collision.</p>
<p>For context, the human genome is approximately 3*10<sup>6</sup> (billion) nucleotides long, which is much smaller than 3.4*10<sup>38</sup>. Viruses have even shorter genomes, ranging in kilo (thousand) nucleotides, for example, the RSV genome is approximately 15*10<sup>3</sup> nucleotides long which is even shorter than 3.4*10<sup>38</sup> when compared to the human genome.</p>
<p>The number of variations we expect in these genomes is therefore much smaller than 2<sup>128</sup>. As a side note, SHA256 is <a href="https://youtu.be/bBC-nXj3Ng4?t=343">used to uniquely identify bitcoin</a> which there are a lot of.</p>
<h1 id="how-much-variation-can-actually-occur">How Much Variation Can Actually Occur?</h1>
<p>The short answer is: we don’t know for sure but we can estimate its upper bound.</p>
<p>Given we look at genomes that are in the same species or quasi species we expect 99% similarity.</p>
<ul>
<li><p>1% of the human genome would be approximately 3*10<sup>4</sup> (thirty thousand) nucleotides long.</p></li>
<li><p>1% of RSV would be approximately 15*10<sup>3</sup> (a hundred and fifty) nucleotides long.</p></li>
</ul>
<p>This is the space within which we expect the variation to occur.</p>
<p>Granted, we still don’t know just how much variation could occur, which in reality would depend on the organism, we have reduced the problem space by orders of magnitude below 2<sup>128</sup> making SHA256 look really good.</p>
<p>I expect the biggest problem with SHA256 to come from the space cost of hashing in terms of both disk and/or memory.</p>

<script src="https://carnivalapp.io/sites/413/init.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", Carnival.init);
</script>

        </article>

        <footer>
  <p>All work is under the terms of the <a href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License, Version 1.3</a></p>
  <p>Generated with <a href="https://jaspervdj.be/hakyll/">Hakyll</a>.</p>
        </footer>
      </div> <!-- #wrapper -->
    </body>
</html>
