<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <link rel="apple-touch-icon" sizes="57x57" href="../images/favicon/apple-icon-57x57.png">
        <link rel="apple-touch-icon" sizes="60x60" href="../images/favicon/apple-icon-60x60.png">
        <link rel="apple-touch-icon" sizes="72x72" href="../images/favicon/apple-icon-72x72.png">
        <link rel="apple-touch-icon" sizes="76x76" href="../images/favicon/apple-icon-76x76.png">
        <link rel="apple-touch-icon" sizes="114x114" href="../images/favicon/apple-icon-114x114.png">
        <link rel="apple-touch-icon" sizes="120x120" href="../images/favicon/apple-icon-120x120.png">
        <link rel="apple-touch-icon" sizes="144x144" href="../images/favicon/apple-icon-144x144.png">
        <link rel="apple-touch-icon" sizes="152x152" href="../images/favicon/apple-icon-152x152.png">
        <link rel="apple-touch-icon" sizes="180x180" href="../images/favicon/apple-icon-180x180.png">
        <link rel="icon" type="image/png" sizes="192x192" href="../images/favicon/android-icon-192x192.png">
        <link rel="icon" type="image/png" sizes="32x32" href="../images/favicon/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="96x96" href="../images/favicon/favicon-96x96.png">
        <link rel="icon" type="image/png" sizes="16x16" href="../images/favicon/favicon-16x16.png">
        <link rel="manifest" href="../images/favicon/manifest.json">
        <meta name="msapplication-TileColor" content="#ffffff">
        <meta name="msapplication-TileImage" content="/images/favicon/ms-icon-144x144.png">
        <meta name="theme-color" content="#ffffff">
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <title>Creating the Initial Variation Graph urbanslug</title>
    </head>
    <body>
      <div id="wrapper">
        <header>
          <div id="header-content">
            <nav>
                <a href="../">Home</a>
                <a href="../notes.html">Notes</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../subscribe.html">Subscribe</a>
            </nav>
          </div><!--header-content-->
        </header>
        <article>
          <h1 id="post-title">Creating the Initial Variation Graph</h1>
          <div class="info">
    Posted on July 15, 2019
    
</div>
<div class="info">
    
    Tags: <a href="../tags/variation%20graphs.html">variation graphs</a>, <a href="../tags/graphs.html">graphs</a>, <a href="../tags/bioinformatics.html">bioinformatics</a>
    
</div>

<p>Variation graphs represent the reference genome as a graph. For an introduction, read my previous post <a href="2019-06-22-Introduction-to-Variation-Graphs.html">An Introduction to Variation Graphs</a> or <a href="https://ekg.github.io/2019/07/09/Untangling-graphical-pangenomics">Untangling graphical pangenomics</a> by Erik Garrison.</p>
<p>Core to variation graphs is the maintenance of a tight mapping between the reference and the graph. To maintain this mapping we establish a <em>coordinate system</em> — a way to reliably associate a node in the graph, with a position in the reference and vice versa. <img src="../images/Content/Graphs/coordinate_system.png" alt="coordinate systems" /></p>
<h1 id="a-coordinate-system">A Coordinate System</h1>
<p>We use the concepts <strong>offset</strong> and <strong>ref</strong> to maintain a coordinate system.</p>
<p>An <strong>offset</strong> is the number of bases from the first node where the variation occurs; offsets are one-indexed in the reference but zero-indexed in the graph. Offsets are suited to translating linear reference to graphs because it’s how variations are viewed within the reference anyway.</p>
<p>For example, we could represent a variation “A” occuring at position 3 in the reference “ATCGAT” as: <img src="../images/Content/Graphs/offsets.svg" alt="offsets" /></p>
<p><em>Notice how we start counting from 0 in the graph? We call that being zero-indexed.</em></p>
<p>A <strong>ref</strong> is a unique identifier which we get from the reference <a href="https://en.wikipedia.org/wiki/FASTA_format#Description_line">description line</a>. A graph created from just one reference will have all nodes contain the same value in the <code>ref</code> field.</p>
<p>As you may have suspected, some problems arise from this coordinate system. They are a matter of <em>progressive update</em> and <em>read alignment</em> but not a matter of initial graph construction and are therefore beyond the scope of this post. They include:</p>
<ol style="list-style-type: decimal">
<li>Dealing with nodes that are from alignments i.e. not aligned to a linear sequence</li>
<li>Changes in the linear reference which change the coordinate system.</li>
</ol>
<h1 id="structure-of-the-graph">Structure of the Graph</h1>
<p>Properties of our graph:</p>
<ol style="list-style-type: decimal">
<li>Directed acyclic graph</li>
<li>Offsets are <strong>increasing/ascending</strong> natural numbers as we walk through the graph</li>
</ol>
<h2 id="node">Node</h2>
<p>A node is built out of a racket <code>structure</code>, a <code>struct</code> in many languages, with the following fields:</p>
<table>
<thead>
<tr class="header">
<th align="center">Name</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">segment</td>
<td align="center">a string of alphabet A, T, C, and G</td>
</tr>
<tr class="even">
<td align="center">offset</td>
<td align="center">offset from zero on the reference</td>
</tr>
<tr class="odd">
<td align="center">id</td>
<td align="center">sha256 hash of the concatenation of segment, “+” and offset</td>
</tr>
<tr class="even">
<td align="center">ref</td>
<td align="center">reference from which the segment is derived</td>
</tr>
<tr class="odd">
<td align="center">links</td>
<td align="center">a list of the IDs of the next nodes</td>
</tr>
</tbody>
</table>
<p>The use of <code>segment</code> and <code>links</code> to mean <code>vertices</code> and <code>edges</code> are inspired by <a href="https://lh3.github.io/2014/07/19/a-proposal-of-the-grapical-fragment-assembly-format">A proposal of the Graphical Fragment Assembly format</a>.</p>
<p>We generate a sha256 hash out of the segment, a plus symbol and the offset to generate a value for <code>id</code>.</p>
<p>For example, given a segment <em>“ATCGATG”</em> at offset <em>34</em> we can generate an ID like so:</p>
<pre><code>generate-id(&lt;string&gt; segment, &lt;natural-number&gt; offset)
  // take note of the + sign in the concatenation
  string-and-offset  &lt;- concatenate(&quot;ATCGATG&quot;, &quot;+&quot;,&quot;34&quot;)
  hash-as-bytestring &lt;- sha256hash(string-and-offset)
  id                 &lt;- bytestring-to-hex-string(hash-as-bytestring)
  return id</code></pre>
<p>I chose hashes over UUIDs because they are reproducible and will have constant time lookups in the occasion that we want to retrieve a node from the graph given its sequence and offset. This should come in handy in visualization especially on the web.</p>
<p>I also considered the likelihood of collisions in the hashes. I expect it to be low when dealing with 15,000 base pair size viruses. I shall expound on this in a later post. One thing to note is that <a href="https://github.com/vgteam/vg">vg</a> uses UUIDs and they work for human genome so I believe <a href="https://github.com/urbanslug/graphite">graphite</a>, the tool that I’m writing to implement this, can get away with sha256 hashes for more complex genomes.</p>
<h2 id="variation">Variation</h2>
<p>A variation is a <code>structure</code> containing the following fields:</p>
<table>
<thead>
<tr class="header">
<th align="center">Name</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">segment</td>
<td align="center">a string of single of alphabet A, T, C, and G</td>
</tr>
<tr class="even">
<td align="center">offset</td>
<td align="center">offset from zero on the reference</td>
</tr>
<tr class="odd">
<td align="center">ref</td>
<td align="center">an identifier of the reference it’s derived from</td>
</tr>
</tbody>
</table>
<p>It is extracted from a <a href="https://en.wikipedia.org/wiki/Variant_Call_Format">Variant Call Format</a> file, the main file format for genomic variation data.</p>
<h2 id="the-graph">The Graph</h2>
<p>I had to implement a graph in graphite due to the lack of serialization (a required feature for progressive updates) in the <a href="https://github.com/stchang/graph">racket graph library</a>; I would have preferred to <a href="https://github.com/stchang/graph/issues/47">add serialization support to graph</a> but couldn’t do that and still stay on track with graphite.</p>
<p>The graph is built out of an adjacency map of <code>id</code>, key, to <code>node</code>, value.</p>
<p>Using a <code>hash table</code> and not a <code>list</code> has the following pros:</p>
<ul>
<li>No duplicates</li>
<li>Constant-time lookups if we have a <code>segment</code> and its <code>offset</code></li>
</ul>
<p>and cons:</p>
<ul>
<li>Lacks ordering despite linear offsets which would come in handy for updates</li>
</ul>
<h1 id="construction">Construction</h1>
<p>The general idea is:</p>
<ol style="list-style-type: decimal">
<li>Given a <code>list</code> of variation <code>structures</code> <strong>sorted</strong> by <code>offset</code> and a linear reference (<code>string</code>)</li>
<li>Loop through each variation and insert an alternative segment into the reference at the position specified in the variation.</li>
</ol>
<p>In the case of graphite, we recursively split the reference into a <em>list</em> of <em>pairs</em> that imply directionality. For example, the pair <code>(a b)</code> would translate to an edge from <em>node a</em> to <em>node b</em>.</p>
<p>We then have a function <code>gen-directed-graph</code> that takes this <code>list</code> of <code>pairs</code> and generates a directed graph from it using <code>foldl</code>. Graphite creates the graph in the 3 steps detailed below.</p>
<h2 id="generate-a-node-list-of-pairs">1. Generate a Node List (of Pairs)</h2>
<p><em>O(n)</em>; n being the size of the variation list</p>
<pre><code>gen-node-list(reference, variations, prev-position = f, prev-nodes = &lt;empty-list&gt;)
  if empty-list? variations
    // the base case of gen node list
    cap(reference, previous-position, previous-nodes)
  else if (is-number previous-position) and (previous-position = current-offset)
    // we have more than one variation in this position
    handle-duplicate(reference, variations, previous-position, previous-nodes)
  else
    // we have just one variation in this position
    handle-unique(reference, variations, previous-position, previous-nodes)</code></pre>
<ul>
<li><strong>reference</strong>: the linear reference</li>
<li><strong>variations</strong>: a list of variations</li>
<li><strong>prev-position</strong>: the offset of the previous variation
<ul>
<li>the default value is false. (I wish I used an int here)</li>
</ul></li>
<li><strong>prev-nodes</strong>: the previous node or nodes with relation to the current one
<ul>
<li>the default value is an empty list.</li>
</ul></li>
</ul>
<p>A mutually recursive function takes from the <code>tail</code> of variation list, <code>variations</code>, and returns a list of pair of nodes <code>(a, b)</code> where the direction of the nodes is <code>a -&gt; b</code> for example a list like <code>[(a b), (b c), (c d)]</code> should later translate to <code>a -&gt; b -&gt; c -&gt; d</code>.</p>
<h3 id="cap">1.1 Cap</h3>
<p>Creates the initial variation i.e “caps” the directed graph. It creates a first node that points to the first variations.</p>
<pre><code>cap(reference, previous-position, previous-nodes)
  map(
    lambda node: (substring(reference, 0, previous-position), node)
    previous-nodes
    )</code></pre>
<h3 id="handle-unique">1.2 Handle Unique</h3>
<p>Inserts a variation where there isn’t an alternative. In a case where there’s only 1 alternative path so we break the current sequence and insert our alternative path, for example, <code>a -&gt; b</code> and <code>a -&gt; c</code>.</p>
<pre><code>handle-unique(reference, variations, previous-position, previous-nodes)
  ...</code></pre>
<h3 id="handle-duplicate">1.3 Handle Duplicate</h3>
<p>Inserts extra alternative variations where they already exist. for example <code>a -&gt; b</code>, <code>a -&gt; c</code> and <code>a -&gt; d</code>.</p>
<pre><code>handle-duplicate(reference, variations, previous-position, previous-nodes)
  ...</code></pre>
<h2 id="generate-a-directed-graph-out-of-a-list-of-pairs">2. Generate a Directed Graph Out of a List of Pairs</h2>
<p><em>O(n)</em>; with n being the size of the list of pairs</p>
<pre><code>gen-directed-graph(g, list-of-pairs)
  foldl(
  // make sure that you're not overwriting the list of edges of a node as you
  // update it. This check makes `gen-directed-graph` slow approx 4n.
  lambda pair: add-adjacent-node(g, first(pair), second(pair))
  g
  list-of-pairs)</code></pre>
<ul>
<li><strong>g</strong>: a graph</li>
<li><strong>list-of-pairs</strong>: a list of pairs</li>
</ul>
<p>The reason for the bad performance of <code>gen-directed-graph</code> is that it checks to avoid overwriting any existing nodes. This is to mean that if there’s a relationship like: <code>a -&gt; b</code> and <code>a -&gt; c</code> we have to make sure not to lose the edge <code>a -&gt; b</code> when creating <code>a -&gt; c</code>. It, however, does suffice for virus data.</p>
<h2 id="return-a-variation-graph">3. Return a Variation Graph</h2>
<p>A composition of <code>gen-node-list</code> and <code>gen-directed-graph</code></p>
<pre><code>gen-vg(reference, variations)
  node-list &lt;- gen-node-list(reference, variation)
  graph     &lt;- gen-directed-graph(node-list)
  return graph</code></pre>
<h1 id="visualization-and-output">Visualization and Output</h1>
<p>Graphite supports the generation of graphs in: <a href="https://github.com/GFA-spec/GFA-spec">GFA</a>, for interoperability with tools such as <a href="https://github.com/vgteam/vg">vg</a> and <a href="https://rrwick.github.io/Bandage/">bandage</a>; <a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language)">DOT</a>, for visualization; and a serialized form, .gra.</p>
<h1 id="optimization-idea">Optimization Idea</h1>
<p>Representing the alphabet in 4 bits, <a href="https://github.com/biod/BioD/blob/57c81f275faab5cdec4746bfc7af81e31bac0f69/bio/core/base.d#L64">as is done in BioD</a>, because:</p>
<ul>
<li>the extra bits accommodate ambiguous bases</li>
<li>we could then perform fast and efficient complimenting though bit shifting</li>
</ul>
<p>The alphabet would be:</p>
<ul>
<li>A as 0001</li>
<li>C as 0010</li>
<li>T as 0100</li>
<li>G as 1000</li>
</ul>
<p>However, most of the optimization would come from graph creation, graph update and search which is what I’m focused on for now.</p>

<script src="https://carnivalapp.io/sites/413/init.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", Carnival.init);
</script>

        </article>

        <footer>
  <p>All work is under the terms of the <a href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License, Version 1.3</a></p>
  <p>Generated with <a href="https://jaspervdj.be/hakyll/">Hakyll</a>.</p>
        </footer>
      </div> <!-- #wrapper -->
    </body>
</html>
